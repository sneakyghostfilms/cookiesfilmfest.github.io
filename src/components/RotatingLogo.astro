---
interface Props {
  size?: number;
  class?: string;
}

const { size = 400, class: className = '' } = Astro.props;
---

<div class={`rotating-logo-container ${className}`} data-size={size}>
  <canvas class="rotating-logo-canvas"></canvas>
  <noscript>
    <img src="/assets/logo-full.svg" alt="Cookies & Comedy Film Festival" class="logo-fallback" />
  </noscript>
</div>

<script>
  import * as THREE from 'three';
  import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';

  function initRotatingLogo() {
    const containers = document.querySelectorAll('.rotating-logo-container');

    containers.forEach((container) => {
      const canvas = container.querySelector('.rotating-logo-canvas') as HTMLCanvasElement;
      if (!canvas || canvas.dataset.initialized) return;

      canvas.dataset.initialized = 'true';

      const size = parseInt(container.getAttribute('data-size') || '400', 10);

      // Scene setup
      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.z = 5;

      // Renderer
      const renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
        antialias: true,
      });
      renderer.setSize(size, size);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const frontLight = new THREE.DirectionalLight(0xffffff, 0.8);
      frontLight.position.set(0, 0, 5);
      scene.add(frontLight);

      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
      backLight.position.set(0, 0, -5);
      scene.add(backLight);

      // Gold rim lights
      const rimLight1 = new THREE.DirectionalLight(0xffd700, 0.4);
      rimLight1.position.set(3, 0, 0);
      scene.add(rimLight1);

      const rimLight2 = new THREE.DirectionalLight(0xffd700, 0.4);
      rimLight2.position.set(-3, 0, 0);
      scene.add(rimLight2);

      // Group to hold the logo
      const logoGroup = new THREE.Group();
      scene.add(logoGroup);

      // Load and parse SVG
      const loader = new SVGLoader();

      loader.load('/assets/logo-full.svg', (data) => {
        const paths = data.paths;

        // Extrusion settings for cookie base
        const cookieExtrudeSettings = {
          depth: 30, // thickness of the coin
          bevelEnabled: true,
          bevelThickness: 5,
          bevelSize: 3,
          bevelSegments: 3,
        };

        // Total cookie thickness for reference
        const cookieTotalDepth = cookieExtrudeSettings.depth + (cookieExtrudeSettings.bevelThickness * 2);

        // Extrusion settings for text - goes all the way through cookie plus sticks out
        const textExtrudeSettings = {
          depth: cookieTotalDepth + 20, // extends beyond cookie on both sides
          bevelEnabled: true,
          bevelThickness: 2,
          bevelSize: 1,
          bevelSegments: 2,
        };

        // Materials
        const goldMaterial = new THREE.MeshStandardMaterial({
          color: 0xd4a84b,
          metalness: 0.8,
          roughness: 0.2,
          side: THREE.DoubleSide,
        });

        // Process each path from the SVG
        paths.forEach((path) => {
          const fillColor = path.userData?.style?.fill;

          // Skip paths with no fill or 'none'
          if (!fillColor || fillColor === 'none' || fillColor === 'transparent') {
            return;
          }

          // Create material based on fill color
          let material: THREE.MeshStandardMaterial;

          if (fillColor === '#c69c6d' || fillColor === 'rgb(198, 156, 109)') {
            // Cookie base color
            material = new THREE.MeshStandardMaterial({
              color: 0xc69c6d,
              metalness: 0.1,
              roughness: 0.6,
              side: THREE.DoubleSide,
            });
          } else if (fillColor === '#ffffff' || fillColor === 'white' || fillColor === 'rgb(255, 255, 255)') {
            // White text/decorations - FrontSide only to prevent see-through
            material = new THREE.MeshStandardMaterial({
              color: 0xffffff,
              metalness: 0.1,
              roughness: 0.3,
              side: THREE.FrontSide,
            });
          } else if (fillColor === '#0c0a3a' || fillColor === 'rgb(12, 10, 58)') {
            // Dark blue elements - FrontSide only to prevent see-through
            material = new THREE.MeshStandardMaterial({
              color: 0x0c0a3a,
              metalness: 0.1,
              roughness: 0.3,
              side: THREE.FrontSide,
            });
          } else {
            // Default material - FrontSide only
            material = new THREE.MeshStandardMaterial({
              color: fillColor ? new THREE.Color(fillColor) : 0xcccccc,
              metalness: 0.1,
              roughness: 0.5,
              side: THREE.FrontSide,
            });
          }

          // Check if this is the cookie base (outer shape)
          const isCookieBase = fillColor === '#c69c6d' || fillColor === 'rgb(198, 156, 109)';

          const shapes = SVGLoader.createShapes(path);

          shapes.forEach((shape) => {
            if (isCookieBase) {
              // Main extruded cookie shape
              const geometry = new THREE.ExtrudeGeometry(shape, cookieExtrudeSettings);
              const mesh = new THREE.Mesh(geometry, [material, goldMaterial]);
              logoGroup.add(mesh);
            } else {
              // Offset white (shadow) elements behind dark blue text to prevent z-fighting
              const isWhite = fillColor === '#ffffff' || fillColor === 'white' || fillColor === 'rgb(255, 255, 255)';
              const isDarkBlue = fillColor === '#0c0a3a' || fillColor === 'rgb(12, 10, 58)';

              // White shadow gets shorter extrusion so it doesn't overlap on back
              const shadowExtrudeSettings = {
                depth: cookieTotalDepth + 10, // less stick-out than main text
                bevelEnabled: true,
                bevelThickness: 1,
                bevelSize: 0.5,
                bevelSegments: 2,
              };

              const extrudeOpts = isWhite ? shadowExtrudeSettings : textExtrudeSettings;
              const geometry = new THREE.ExtrudeGeometry(shape, extrudeOpts);
              const mesh = new THREE.Mesh(geometry, material);

              // Position so text is centered through the cookie
              let startZ = -cookieExtrudeSettings.bevelThickness - 10; // 10 units stick out back

              if (isWhite) {
                startZ = -cookieExtrudeSettings.bevelThickness - 5; // shadow starts closer, ends shorter
              } else if (isDarkBlue) {
                startZ += 2; // Dark text slightly in front
              }

              mesh.position.z = startZ;
              logoGroup.add(mesh);
            }
          });
        });

        // Center and scale the logo
        const box = new THREE.Box3().setFromObject(logoGroup);
        const center = box.getCenter(new THREE.Vector3());
        const logoSize = box.getSize(new THREE.Vector3());

        // Translate each child to center around origin (don't use group position)
        logoGroup.children.forEach((child) => {
          child.position.x -= center.x;
          child.position.y -= center.y;
          child.position.z -= center.z;
        });

        // Scale to fit view - use smaller scale to prevent clipping during rotation
        const maxDim = Math.max(logoSize.x, logoSize.y);
        const scale = 2.2 / maxDim;
        logoGroup.scale.set(scale, -scale, scale); // Negative Y to flip right-side up

        // Position camera to see the full object during rotation
        camera.position.z = 3;
      },
      undefined,
      (error) => {
        console.error('SVG load error:', error);
      });

      // Animation state
      const rotationSpeed = 0.008;

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Rotate around Y axis
        logoGroup.rotation.y += rotationSpeed;

        renderer.render(scene, camera);
      }

      animate();

      // Handle resize
      const resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const width = entry.contentRect.width;
          if (width > 0) {
            renderer.setSize(width, width);
          }
        }
      });

      resizeObserver.observe(container);
    });
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initRotatingLogo);
  } else {
    initRotatingLogo();
  }

  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', initRotatingLogo);
</script>

<style>
  .rotating-logo-container {
    width: 100%;
    max-width: 100%;
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: default;
  }

  .rotating-logo-canvas {
    width: 100% !important;
    height: 100% !important;
  }

  .logo-fallback {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }
</style>
